# OBON (Optimized Binary Object Notation)

The Optimized Binary Object Notation (OBON) is a special object notation created and optimized for `@julman/reviver`.

Warning: This notation is optimized for minimum size, not for parcouring, parsing and serialization.

This notation doesn't supports all JSON features but supports all data generated by `@julman/reviver`.

 - No object notations supported
 - No size bytes, using delimeters (`\x03` END OF TEXT)
 - Optimized arrays
 - Unicode support
 - Auto sized numbers serialization (0, 8, 16, 32 or 64 bits ; integers or floats)
 - Supports of "flags" values (null, undefined, nan, +/- inf)
 - Zero data bytes boolean
 - Hidden bytes

## Features

### Optimized array

`@julman/reviver` always output arrays for complex strutures starting with a string, so in OBON an array must start with a string without its starting flag bytes.

Arrays are optimized since:

 - Only one byte is enough to declare an array. Can be two if flags are extended.
 - One byte to end an array.
 - There's no seperator between values.
 - There's no size bytes.
 - There's no key before values, different from BSON.
 - There's no padding bytes.

### Hidden bytes

The hidden bytes is a feature that can save up to 127 repeated bytes for each extented flag structure.

If set, the first first byte is virtually repeated the number of times given in the flag.

Example:

```
; This take 3 storage bytes
80 b6 01
; 0xb6 = 0x80 | 54

; But extends in 54 real bytes
01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01
01 01 01 01 01 01 01 01
01 01 01 01 01 01 
```

Note: the deserializer will provides an error

## Glossary

### Storage size/bytes

The storage size is the number of bytes taken by the data once serialized and optimized in OBON.

### Real size/bytes

The real size is the number of bytes taken by the data after deserialization.

### Note ratio

The node ratio is the ratio real bytes over storage bytes taken. The worst ratio is zero.

These aren't counted in storage bytes: 

 - The flags if focused on the real value
 - The data byte required for hidden bytes

## Structure

### Flags

A flag is a special value (1 byte — 2 if extended) that precises the very next value.

First byte:

 - 1<<7: Extended flag. Another flag byte should follow if high.
 - 1<<6: Sign flag.
 - 1<<5: Null flag.
 - 1<<4: Integer flag. This flag doesn't mean the following data is an integer.
 - 1<<3, 1<<2, 1<<1 and 1<<0: Type flag.

Second byte, if extended:

 - 1<<7: Hidden bytes flag.
 - 1<<6, 1<<5, 1<<4, 1<<3, 1<<2, 1<<1 and 1<<0: Hidden bytes count flag. Ignored if hidden bytes flag is low.

Note: If hidden bytes flag is high, the next byte isn't counted as a flags byte, so not counted in ratios.

Node ratio:

 - Average: 0 for 1 (loss of efficiency)
 - Special values:
   - Average: 1 for 1 (neutral)
   - One byte:
     - Worst: 1 for 1
     - Best: 1 for 1
   - Extended:
     - Worst: 1 for 2
     - Best: 127 for 2
 - One byte:
   - Worst: 0 for 1
   - Best 1 for 1
 - Extended:
   - Worst: 0 for 2
   - Best: 126 for 2

#### Special Values

Here is the list of special values supported by OBON:

| Value | Sign flag | Null flag | Integer flag | Type flag |
|---|---|---|---|---|
| `null` | 0 | 1 | 0 | None |
| `undefined` | 1 | 1 | 0 | None |
| `+inf` | 0 | 0 | 1 | None |
| `-inf` | 1 | 0 | 1 | None |
| `nan` | 0 | 1 | 1 | None |
| Precise zero (integer or float) | 1 | 1 | 1 | None |
| Boolean `false` | 0 | 0 | 0 | Boolean |
| Boolean `true` | 1 | 0 | 0 | Boolean |

#### Type flag

Here is the list of all types storable by the flags type.

Note: The column "Bytes after" is bytes counted after hidden bytes expanding.

| Type                    | Bytes after | 1<<3 | 1<<2 | 1<<1 | 1<<0 |
|-------------------------|-------------|------|------|------|------|
| Boolean                 | 0           | 0    | 0    | 0    | 1    |
| Unsigned 8-bit integer  | 1           | 0    | 0    | 1    | 0    |
| Unsigned 16-bit integer | 2           | 0    | 0    | 1    | 1    |
| Unsigned 32-bit integer | 4           | 0    | 1    | 0    | 0    |
| Unsigned 64-bit integer | 8           | 0    | 1    | 0    | 1    |
| Signed 8-bit integer    | 1           | 0    | 1    | 1    | 0    |
| Signed 16-bit integer   | 2           | 0    | 1    | 1    | 1    |
| Signed 32-bit integer   | 4           | 1    | 0    | 0    | 0    |
| Signed 64-bit integer   | 8           | 1    | 0    | 0    | 1    |
| 32-bit IEEE 754 float   | 4           | 1    | 0    | 1    | 0    |
| 64-bit IEEE 754 float   | 8           | 1    | 0    | 1    | 1    |
| String                  | ≥ 1         | 1    | 1    | 0    | 0    |
| Sized string            | ≥ 1         | 1    | 1    | 0    | 1    |
| Array                   | ≥ 2         | 1    | 1    | 1    | 0    |

### Unsigned 8-, 16-, 32- and 64-bit integers

Defining N the number of bits for the integer and B = N / 8.

There's no end delimiter for intergers since they are sized.

The bits represents the absolute value of the number if non-negative or the distance to -2^(N-1) if negative.

Example for 8-bit:

```
0100 0110 ; = 70
1111 1111 ; = 255
0111 1111 ; = 127
1000 0000 ; = 128
```

Node ratio:

 - Average: neutral (B for B)
 - Worst: neutral
 - Best: B for 0 (using hidden bytes)
 
### Signed 8-, 16-, 32- and 64-bit integers

Defining N the number of bits for the integer and B = N / 8.

There's no end delimiter for intergers since they are sized.

The MSB is always the sign bit.

The leading bits represents the absolute value of the number if non-negative or the distance to -2^(N-1) if negative.

Example for 8-bit:

```
0100 0110 ; = 70
1111 1111 ; = -1
0111 1111 ; = 127
1000 0000 ; = -128
```

Node ratio:

 - Average: neutral (B for B)
 - Worst: neutral
 - Best: B for 0 (using hidden bytes)

### 32- and 64-bits IEEE 754 floats

OBON stores floats using

 - binary32 or
 - binary64

depending of the length of bits.

